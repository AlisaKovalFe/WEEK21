Ответы на вопросы теста
1. GET запрос, примеры:

https://www.ozon.ru/category/zubnye-shchetki-6322/?cruelty=45795&deny_category_prediction=true&from_global=true&text=зубная+щетка- выбирает зубные щетки со мягкою степенью жетскости (код степени жесткости 45795)

https://www.mvideo.ru/product-list-page/f/tolko-v-nalichii=da/diagonal=55---64?q=телевизоры&category=televizory-65 - выбирает телевизора в диагонали 55-64, которые в наличие

https://vkusvill.ru/search/?q=томаты+сливовидные&type=products - выбирает сливовидные томаты


2. GET запрашивает данные из указанного ресурса (основное - парметры отправляет как часть пути прямо в строке адреса, запросы кэшируются, сохраняются в истории браузреа, не должны использоваться с конфиденциальными данными, данный метод подходит только для извлечения данных)
POST отправляет данные для обработки в указанный ресурс (он что-то меняет (в ресурс вносятся изменения), метод отправляет запрос в теле HTTP-сообщения так, что тут пользователь не видит пары "ключ-значение", они спрятаны, соответственно параметры не кэшируются, не остаются в истории браузера, конфиденциальность сохраняется, используется для операций с большими данными )

3. Для отфильтрованного списка подойдет GET запрос, так как это неконфиденциальная информация

4. Для формы регистрации нужно использовать POST запрос, так как логин и пароль и др. данные пользователя являются конфиденциальной информацией

5. здесь запрашиваются гифки по апи ключу (я свой создала), выбираются картинки кошек в количесте 25 штук с рейтингом g, lang - это выбор страны по умолчанию для подборки регионального контента

чтобы возвращать 5 картинок нужно поменять limit (внизу запрос с созданным мною ключом)

https://api.giphy.com/v1/gifs/search?api_key=ILy7aNThR6MbeADiAl9PV4SlwkYtad2B&q=cats&limit=5&offset=0&rating=g&lang=en



6. Заголовки запроса к странице или API можно посмотреть в девтулзах во вкладке "сеть" и там в разделе все (или выбрать то, что нужно, например, изображения)

7. Политика «CORS»: Cross-Origin Resource Sharing («совместное использование ресурсов между разными источниками»).
Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. 

Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищённому соединению. Современные браузеры используют CORS в API-контейнерах, таких как XMLHttpRequest или Fetch, чтобы снизить риски, присущие запросам с других источников.

При запросе на другой источник браузер всегда ставит «от себя» заголовок Origin. Сервер может проверить Origin и, если он согласен принять такой запрос, добавить особый заголовок Access-Control-Allow-Origin к ответу. Здесь браузер играет роль доверенного посредника.
 
в fetch:
fetch(url, {
    method: 'POST', 
    mode: 'cors', // no-cors, *cors, same-origin
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });

same-origin — Если запрос сделан к другому origin в этом режиме, то это вызовет ошибку. Можно использовать этот режим, чтобы проверить, что запрос всегда будет обращён к тому же origin, что и текущий.

no-cors — Разрешает использование только HEAD, GET или POST методов и простых заголовков . Если какой-либо ServiceWorkers перехватит запрос, то он не сможет добавить или изменить заголовки, кроме простых. 
cors — Разрешает кросс-доменные запросы. Например, чтобы получить доступ к некому API, предоставляемое третей стороной. Ожидается, что запрос в этом режиме будет придерживаться CORS протокола. В объекте ответа Response доступен ограниченный набор заголовков, но тело доступно для чтения.

8. в параметрах заголовках Content-Type можно писать:
application/x-www-form-urlencoded, multipart/form-data,  text/plain, application/json (это самые распространенные типы)

9. ниже код, чтобы отправить данные в API (сам адрес взят из задания)

fetch ('localhost/pets/add', 
{
    method: 'POST',
    body: json,
})

10. Promise  – это специальный объект в JavaScript, который связывает «создающий» (например, загрузка данных по сети) и «потребляющий» (использует результат создающего кода, когда тот будет готов) коды вместе.
Промисы позволяют улучшить порядок кода и дают нам гибкость.

Синтаксис:
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
});

Функция-исполнитель запускается сразу же при вызове new Promise.
Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript. Нам нужно, чтобы исполнитель вызвал одну из них по готовности.
resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки.

С помощью промисов можно, например, явно указать, что выполнить что-то нужно после того, как загрузится сторонник скрипт 

Мы сталкивались с этим, когда использовали метод fetch
fetch ('url')
    .then (response => response.json())
    .then (user => console.log(user))
    .catch (err => console.log(err))

здесь мы прописывали, что только после стягивания данных нужно распарсить их в объект и уже далее вывести их в консоль, либо вывести ошибку в консоль (тут еще используем метод then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат)




